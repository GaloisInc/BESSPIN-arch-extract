#lang racket

(provide
  (struct-out ftree)
  (struct-out fnode)
  mk-name
  name-str

  ftree-child-map
  ftree-non-group-feature-order

  (struct-out name)
  (struct-out name-list)
  feature-name-list

  ftree->feature-model
  ftree-complete-order!
  ftree-split-opt-groups!
  ftree-force-card-opt!

  feature-model->ftree
  ftree-names-as-ids!
  ftree-collapse-groups!
  ftree-constraints-to-cards!

  ftree-split-constraints!
  )

(require racket/hash)
(require "types.rkt")
(require "util.rkt")


(struct ftree
  (
   ; Mutable hash mapping feature IDs to fnodes.  Feature IDs are arbitrary
   ; strings.
   features
   ; List of constraints, referencing features via `(feature ,id)` syntax.
   constraints
   ; List of feature IDs.  Used for sorting the features when converting to
   ; other formats.  This is a hint only - keys in `features` may be absent
   ; from `feature-order`, and vice versa.
   feature-order
   )
  #:transparent #:mutable)

(struct fnode
  (
   name
   parent
   ; Cardinality of this feature: one of 'opt, 'on, 'off
   card
   ; Group cardinality of this feature: one of 'opt, 'or, 'mux, 'xor
   gcard
   )
  #:transparent #:mutable)

; The name of an `fnode`: a string, plus an integer indicating its level of
; "auto-generated-ness".
(struct name (str auto) #:transparent)

(define (mk-name s [auto 0])
  (name s auto))

(define (ftree-feature ft x)
  (hash-ref (ftree-features ft) x))

(define (name-derive f n [auto 10])
  (name (f (name-str n)) (+ auto (name-auto n))))

(define (fresh-id base in-use)
  (if (not (in-use base))
    base
    (let loop ([i 0])
      (define name (format "~a~a" base i))
      (if (not (in-use name))
        name
        (loop (add1 i))))))

(define (fresh-name base in-use [auto 1])
  (define s (fresh-id (name-str base) in-use))
  (define more-auto (if (equal? s (name-str base)) 0 auto))
  (name s (+ more-auto (name-auto base))))

; Choose whichever of `n1` and `n2` is "less auto-generated".  Picks `n1` is
; case of a tie.
(define (choose-name n1 n2)
  (if (<= (name-auto n1) (name-auto n2)) n1 n2))


; The `feature-model` representation doesn't have fields for storing feature
; and group names.  `ftree->feature-model` splits the names out into a
; `name-list`, and `feature-model->ftree` uses the `name-list` to reassociate
; names with features and groups.
(struct name-list (features groups order) #:transparent)

(define (feature-name-list feature-names)
  (name-list feature-names #f #f))


; Build a hashmap that maps each feature ID to a set of the IDs of its
; children.
(define (ftree-child-map ft)
  (define m (make-hash))
  (for ([k (in-hash-keys (ftree-features ft))])
    (hash-set! m k (mutable-set)))
  (hash-set! m #f (mutable-set))
  (for ([(k f) (ftree-features ft)])
    (set-add! (hash-ref m (fnode-parent f)) k))
  m)

; Compute a new `feature-order` that includes exactly the IDs present in
; `features`, using the existing `feature-order` as a hint.  The result is
; based on a depth-first preorder traversal of the feature tree, using the
; various ordering hints to sort the children of each node.
;
; If provided, `alt-ids` should, given a feature ID, return a list of other IDs
; that are related and should be placed just after the given ID in the sort
; order.
(define (ftree-complete-order ft [alt-ids (lambda (x) '())])
  (define idx-map (make-hash))
  (define next (let ([i 0]) (lambda () (begin0 i (set! i (add1 i))))))

  ; Add entries based on existing feature-order hint and on alt-ids.
  (for ([x (ftree-feature-order ft)])
    ; Position in `ftree-feature-order` overrides one generated by alt-ids.
    (hash-set! idx-map x (next))
    (for ([y (alt-ids x)] #:when (not (hash-has-key? idx-map y)))
      (hash-set! idx-map y (next))))

  ; Add entries for any remaining features, sorted using string<?
  (define leftover
    (for/list ([x (in-hash-keys (ftree-features ft))]
               #:when (not (hash-has-key? idx-map x))) x))
  (for ([x (sort leftover string<?)])
    (hash-set! idx-map x (next)))

  (define (feature-id-< a b)
    (< (hash-ref idx-map a) (hash-ref idx-map b)))
  (define child-map (ftree-child-map ft))
  (define (sorted-children x)
    (sort (set->list (hash-ref child-map x)) feature-id-<))
  (define (walk x)
    (cons x (append-map walk (sorted-children x))))

  (append-map walk (sorted-children #f))
  )

(define (ftree-complete-order! ft [alt-ids (lambda (x) '())])
  (set-ftree-feature-order!
    ft
    (ftree-complete-order ft alt-ids)))

(define (fnode-is-group? fn)
  (not (eq? 'opt (fnode-gcard fn))))

(define (rewrite-constraint f c)
  (let loop ([c c])
    (match c
      [(? boolean? b) b]
      [(cons '&& args) (cons '&& (map loop args))]
      [(cons '|| args) (cons '|| (map loop args))]
      [(cons '! args) (cons '! (map loop args))]
      [(cons '=> args) (cons '=> (map loop args))]
      [(cons '<=> args) (cons '<=> (map loop args))]
      [x (f x)])))

(define (rewrite-constraints f cs)
  (map (lambda (c) (rewrite-constraint f c)) cs))

; Convert an ftree to a feature-model.  Requirements:
; * Each feature in the tree falls into one of three categories:
;   - Top-level features, with gcard = opt and no constraints on card.
;   - Interior features, with gcard = opt and card = opt.
;   - Group features, with gcard != opt and card = on.
; * Each group feature is a child of a non-group feature.
;   (TODO - we don't have a function to enforce this yet, but it only comes up
;   in weird corner cases, since the nested group usually has card = opt, which
;   triggers other transforms)
; * The `feature-order` exactly covers the IDs in `features`
;
; Returns two values: a feature model, and a name-list associating the names
; from `ft` with the features and groups of the feature model.
(define (ftree->feature-model ft)
  (define feature-ids
    (for/list ([x (ftree-feature-order ft)]
               #:when (not (fnode-is-group? (ftree-feature ft x))))
      x))
  (define feature-id-map
    (for/hash ([(x i) (in-indexed feature-ids)])
      (values x i)))

  (define group-ids
    (for/list ([x (ftree-feature-order ft)]
               #:when (fnode-is-group? (ftree-feature ft x)))
      x))
  (define group-id-map
    (for/hash ([(x i) (in-indexed group-ids)])
      (values x i)))

  ; Maps for resolving `fnode-parent` relationships.  `parent-feature-map`
  ; gives the `feature-model` `parent-id` to use (which may or may not match
  ; the value in `feature-id-map`), and `parent-group-map` gives the `group-id`
  ; to use.
  (define parent-feature-map (make-hash))
  (define parent-group-map (make-hash))
  (hash-set! parent-feature-map #f -1)
  (hash-set! parent-group-map #f -1)
  (for ([x (ftree-feature-order ft)])
    (define fn (ftree-feature ft x))
    (if (fnode-is-group? fn)
      (begin
        ; Parent is either #f or a non-group, which appears in feature-id-map.
        (hash-set! parent-feature-map x
          (if-let ([p (fnode-parent fn)]) (hash-ref feature-id-map p) -1))
        (hash-set! parent-group-map x (hash-ref group-id-map x)))
      (begin
        (hash-set! parent-feature-map x (hash-ref feature-id-map x))
        (hash-set! parent-group-map x -1))
      ))

  (define features
    (for/vector ([x feature-ids])
      (define fn (ftree-feature ft x))
      (define parent-x (fnode-parent fn))
      (when (and parent-x (not (eq? 'opt (fnode-card fn))))
        (raise (format "feature ~a has nonempty parent and nondefault cardinality" x)))
      (feature
        (hash-ref parent-feature-map (fnode-parent fn))
        (hash-ref parent-group-map (fnode-parent fn))
        -1  ; depth is set later
        (eq? 'on (fnode-card fn))
        (eq? 'off (fnode-card fn))
        )))

  (define feature-names
    (for/vector ([x feature-ids]) (fnode-name (ftree-feature ft x))))

  (define groups
    (for/vector ([x group-ids])
      (define fn (ftree-feature ft x))
      (define-values (min-card max-card)
        (match (fnode-gcard fn)
          ; Can't be 'opt, otherwise it wouldn't be a group feature.
          ['or (values 1 '*)]
          ['mux (values 0 1)]
          ['xor (values 1 1)]))
      (group
        (if-let ([p (fnode-parent fn)]) (hash-ref feature-id-map p) -1)
        min-card
        max-card
        )))

  (define group-names
    (for/vector ([x group-ids]) (fnode-name (ftree-feature ft x))))

  (define-values (dep-cons normal-cons)
    (partition
      (match-lambda
        [`(=> (feature ,_) (feature ,_)) #t]
        [`(=> (feature ,_) (! (feature ,_))) #t]
        [else #f])
      (ftree-constraints ft)))

  ; Get the feature index to use for `x` in constraints.  This is `x`'s own
  ; index when `x` is a feature, and its parent index when it's a group.
  (define (constraint-feature-id x)
    (define fn (ftree-feature ft x))
    (if (fnode-is-group? fn)
      (hash-ref feature-id-map (fnode-parent fn))
      (hash-ref feature-id-map x)))

  (define (build-dep ax bx val)
    (dependency
      (constraint-feature-id ax)
      (constraint-feature-id bx)
      val))

  (define dependencies
    (for/vector ([c dep-cons])
      (match c
        [`(=> (feature ,ax) (feature ,bx))
          (build-dep ax bx #t)]
        [`(=> (feature ,ax) (! (feature ,bx)))
          (build-dep ax bx #f)])))

  (define constraint
    (cons '&&
      (rewrite-constraints
        (match-lambda [`(feature ,x) (constraint-feature-id x)])
        normal-cons)))

  (define full-order
    (for/vector ([x (ftree-feature-order ft)])
      (if (fnode-is-group? (ftree-feature ft x))
        `(group ,(hash-ref group-id-map x))
        `(feature ,(hash-ref feature-id-map x))
        )))

  (define fm
    (feature-model
      features
      groups
      dependencies
      constraint))

  (values
    (recalc-feature-depths fm)
    (name-list feature-names group-names full-order)
    ))

(define (recalc-feature-depths fm)
  (define depth-map (make-hash))
  (hash-set! depth-map -1 -1)
  (define (depth i)
    (hash-ref! depth-map i
      (lambda ()
        (add1 (depth (feature-parent-id (feature-model-feature fm i)))))))

  (struct-copy feature-model fm
    [features
      (for/vector ([(f i) (in-indexed (feature-model-features fm))])
        (struct-copy feature f [depth (depth i)]))]))

(define (ftree-non-group-feature-order ft)
  (for/list ([k (ftree-feature-order ft)]
             #:when (not (fnode-is-group? (ftree-feature ft k))))
    k))

; Find features with both gcard != opt and card != on, and split them into two
; separate features, one with gcard != opt and a parent feature with card != on
(define (ftree-split-opt-groups! ft)
  (for ([(k fn) (ftree-features ft)]
        #:when (and (fnode-is-group? fn)
                    (not (eq? 'on (fnode-card fn)))))
    (define new-k
      (fresh-id
        (format "~a-parent" k)
        (lambda (n) (hash-has-key? (ftree-features ft) n))))
    (hash-set! (ftree-features ft) new-k
      (fnode
        (name-derive (lambda (s) (format "~a-parent" s)) (fnode-name fn))
        (fnode-parent fn)
        (fnode-card fn)
        'opt))
    (set-fnode-parent! fn new-k)
    (set-fnode-card! fn 'on)))

; Find non-top-level features with card != opt, and replace the card setting
; with a constraint for the same effect.
(define (ftree-force-card-opt! ft)
  (for ([(k fn) (ftree-features ft)]
        #:when (and (not (fnode-is-group? fn))
                    (fnode-parent fn)
                    (not (eq? 'opt (fnode-card fn)))))
    (define rhs
      (match (fnode-card fn)
        ['on `(feature ,k)]
        ['off `(! (feature ,k))]))
    (set-fnode-card! fn 'opt)
    (set-ftree-constraints! ft
      (cons 
        `(=> (feature ,(fnode-parent fn)) ,rhs)
        (ftree-constraints ft)))))


(define (as-name x)
  (cond
    [(name? x) x]
    [(string? x) (mk-name x)]
    [(symbol? x) (mk-name (symbol->string x))]
    [else (raise "can't convert ~a to a name" x)]))

(define (feature-model->ftree names fm)
  (define (ftree-feature-id i) (format "feat-~a" i))
  (define (ftree-group-id j) (format "grp-~a" j))

  (match-define (name-list feature-names group-names _) names)
  (define (get-feature-name i)
    (if-let ([n (and feature-names (vector-ref feature-names i))])
      (as-name n)
      (name (format "feat_~a" (add1 i)) 10)))
  (define (get-group-name j)
    (if-let ([n (and group-names (vector-ref group-names j))])
      (as-name n)
      (name (format "grp_~a" (add1 j)) 10)))

  (define (ftree-feature-parent-id f)
    (cond
      [(not (= -1 (feature-group-id f)))
       (ftree-group-id (feature-group-id f))]
      [(not (= -1 (feature-parent-id f)))
       (ftree-feature-id (feature-parent-id f))]
      [else #f]))

  (define (ftree-group-parent-id g)
    (cond
      [(not (= -1 (group-parent-id g)))
       (ftree-feature-id (group-parent-id g))]
      [else #f]))

  (define fnodes-normal-entries
    (for/list ([(f i) (in-indexed (feature-model-features fm))])
      (define card
        (cond
          [(feature-force-on f) 'on]
          [(feature-force-off f) 'off]
          [else 'opt]))
      (cons
        (ftree-feature-id i)
        (fnode
          (get-feature-name i)
          (ftree-feature-parent-id f)
          card
          'opt
          ))))

  (define fnodes-group-entries
    (for/list ([(g j) (in-indexed (feature-model-groups fm))]
               #:when (match/values (group-cards g) [(0 '*) #f] [(_ _) #t]))
      (define gcard
        (match/values (group-cards g)
          [(0 '*) 'opt]
          [(1 '*) 'or]
          [(0 1) 'mux]
          [(1 1) 'xor]
          [(lo hi) (raise (format "unsupported group cardinality ~a..~a" lo hi))]))
      (cons
        (ftree-group-id j)
        (fnode
          (get-group-name j)
          (ftree-group-parent-id g)
          'on
          gcard
          ))))

  (define fnodes (make-hash (append fnodes-normal-entries fnodes-group-entries)))

  (define dep-constraints
    (for/list ([d (feature-model-dependencies fm)]
               #:when (not (= -1 (dependency-a d))))
      (match-define (dependency a b val) d)
      (if val
        `(=> (feature ,(ftree-feature-id a)) (feature ,(ftree-feature-id b)))
        `(=> (feature ,(ftree-feature-id a)) (! (feature ,(ftree-feature-id b))))
        )))

  (define constraint
    (rewrite-constraint
      (lambda (i) `(feature ,(format "feat-~a" i)))
      (feature-model-constraint fm)))

  (define order
    (if-let ([order (name-list-order names)])
      (for/list ([x order])
        (match x
          [`(feature ,i) (ftree-feature-id i)]
          [`(group ,j) (ftree-group-id j)]))
      (append
        (for/list ([i (in-range (feature-model-num-features fm))])
          (ftree-feature-id i))
        (for/list ([j (in-range (feature-model-num-groups fm))])
          (ftree-group-id j))
        )))

  (ftree
    fnodes
    (cons constraint dep-constraints)
    order
    ))

; Reassign feature IDs based on their names.
(define (ftree-names-as-ids! ft)
  (define id-map
    (let ([used-ids (mutable-set)])
      (for/hash ([k (ftree-complete-order ft)])
        (define fn (ftree-feature ft k))
        (define new-k 
          (fresh-id (name-str (fnode-name fn))
                    (lambda (n) (set-member? used-ids n))))
        (set-add! used-ids new-k)
        (values k new-k))))

  (set-ftree-features! ft
    (make-hash
      (for/list ([(k fn) (ftree-features ft)])
        (define parent
          (and (fnode-parent fn) (hash-ref id-map (fnode-parent fn))))
        (cons
          (hash-ref id-map k)
          (struct-copy fnode fn [parent parent])))))

  (set-ftree-constraints! ft
    (rewrite-constraints
      (lambda (c) (match c [`(feature ,k) `(feature ,(hash-ref id-map k))]))
      (ftree-constraints ft)))

  (set-ftree-feature-order! ft
    (for/list ([old-k (ftree-feature-order ft)] #:when #t
               [new-k (in-value (hash-ref id-map old-k #f))] #:when new-k)
      new-k))
  )

; Find extraneous group/nongroup feature pairs, like those created by
; ftree-split-opt-groups!, and combine them back into single features.
; Specifically, this looks for a `gcard = opt` feature with a `gcard != opt,
; card = on` feature as its only child.
(define (ftree-collapse-groups! ft)
  (define child-map (ftree-child-map ft))
  (define (only-child k)
    (define children (hash-ref child-map k))
    (and (= 1 (set-count children)) (set-first children)))

  (define subst-map
    (for/hash ([(k fn) (ftree-features ft)] #:when (eq? 'opt (fnode-gcard fn))
               [k2 (in-value (only-child k))] #:when k2
               [fn2 (in-value (ftree-feature ft k2))]
               #:when (and (not (eq? 'opt (fnode-gcard fn2)))
                           (eq? 'on (fnode-card fn2))))
      (values k k2)))

  (for ([(k k2) subst-map])
    (define fn (ftree-feature ft k))
    (define fn2 (ftree-feature ft k2))
    (set-fnode-name! fn2 (choose-name (fnode-name fn) (fnode-name fn2)))
    (set-fnode-parent! fn2 (fnode-parent fn))
    (set-fnode-card! fn2 (fnode-card fn))
    (hash-remove! (ftree-features ft) k))

  (set-ftree-constraints! ft
    (rewrite-constraints
      (lambda (c) (match c [`(feature ,k) `(feature ,(hash-ref subst-map k k))]))
      (ftree-constraints ft)))
  )

(define (split-constraint c)
  (match c
    [`(&& ,@cs) (append-map split-constraint cs)]
    [#t '()]
    [else (list c)]))

(define (ftree-split-constraints! ft)
  (set-ftree-constraints! ft
    (append-map split-constraint (ftree-constraints ft))))

(define (ftree-constraints-to-cards! ft)
  ; If `a` is the parent of `b`, and `b`'s cardinality can be safely changed to
  ; `new-card`, then change it and return #t.  Otherwise, return #f.
  (define (maybe-set-card a b new-card)
    (define fn (ftree-feature ft b))
    (and
      (equal? a (fnode-parent fn))
      ; This is the "safe to change cardinality" check.  If the existing
      ; cardinality is 'on, it is *not* safe to change to 'off (and delete the
      ; corresponding constraint), since it would eliminate a contradiction
      ; among the constraints.
      (or (eq? new-card (fnode-card fn))
          (eq? 'opt (fnode-card fn)))
      (begin
        (set-fnode-card! fn new-card)
        #t)))

  (set-ftree-constraints! ft
    (filter
      (match-lambda
        ; If maybe-set-card succeeds, then we want to delete the constraint.
        [`(=> (feature ,a) (feature ,b))
          (not (maybe-set-card a b 'on))]
        [`(=> (feature ,a) (! (feature ,b)))
          (not (maybe-set-card a b 'off))]
        [else #t])
      (ftree-constraints ft))))
