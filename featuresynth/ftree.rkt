#lang racket

(provide
  (struct-out ftree)
  (struct-out fnode)

  ftree-non-group-feature-order

  ftree->feature-model
  ftree-complete-order!
  ftree-split-opt-groups!
  ftree-force-card-opt!
  )

(require "types.rkt")
(require "util.rkt")


(struct ftree
  (
   ; Mutable hash mapping feature IDs to fnodes.  Feature IDs are arbitrary
   ; strings.
   features
   ; List of constraints, referencing features via `(feature ,id)` syntax.
   constraints
   ; List of feature IDs.  Used for sorting the features when converting to
   ; other formats.  This is a hint only - keys in `features` may be absent
   ; from `feature-order`, and vice versa.
   feature-order
   )
  #:transparent #:mutable)

(struct fnode
  (
   name
   parent
   ; Cardinality of this feature: one of 'opt, 'on, 'off
   card
   ; Group cardinality of this feature: one of 'opt, 'or, 'mux, 'xor
   gcard
   )
  #:transparent #:mutable)

(define (ftree-feature ft x)
  (hash-ref (ftree-features ft) x))

; Build a hashmap that maps each feature ID to a set of the IDs of its
; children.
(define (ftree-child-map ft)
  (define m (make-hash))
  (for ([k (in-hash-keys (ftree-features ft))])
    (hash-set! m k (mutable-set)))
  (hash-set! m #f (mutable-set))
  (for ([(k f) (ftree-features ft)])
    (set-add! (hash-ref m (fnode-parent f)) k))
  m)

; Recalculate `feature-order` so it includes exactly the IDs present in
; `features`, using the existing `feature-order` as a hint.  The result is
; based on a depth-first preorder traversal of the feature tree, using the
; various ordering hints to sort the children of each node.
;
; If provided, `alt-ids` should, given a feature ID, return a list of other IDs
; that are related and should be placed just after the given ID in the sort
; order.
(define (ftree-complete-order! ft [alt-ids (lambda (x) '())])
  (define idx-map (make-hash))
  (define next (let ([i 0]) (lambda () (begin0 i (set! i (add1 i))))))

  ; Add entries based on existing feature-order hint and on alt-ids.
  (for ([x (ftree-feature-order ft)])
    ; Position in `ftree-feature-order` overrides one generated by alt-ids.
    (hash-set! idx-map x (next))
    (for ([y (alt-ids x)] #:when (not (hash-has-key? idx-map y)))
      (hash-set! idx-map x (next))))

  ; Add entries for any remaining features, sorted using string<?
  (define leftover
    (for/list ([x (in-hash-keys (ftree-features ft))]
               #:when (not (hash-has-key? idx-map x))) x))
  (for ([x (sort leftover string<?)])
    (hash-set! idx-map x (next)))

  (define (feature-id-< a b)
    (< (hash-ref idx-map a) (hash-ref idx-map b)))
  (define child-map (ftree-child-map ft))
  (define (sorted-children x)
    (sort (set->list (hash-ref child-map x)) feature-id-<))
  (define (walk x)
    (cons x (append-map walk (sorted-children x))))

  (set-ftree-feature-order! ft (append-map walk (sorted-children #f)))
  )

(define (fnode-is-group? fn)
  (not (eq? 'opt (fnode-gcard fn))))

(define (rewrite-constraint f c)
  (let loop ([c c])
    (match c
      [(? boolean? b) b]
      [(cons '&& args) (cons '&& (map loop args))]
      [(cons '|| args) (cons '|| (map loop args))]
      [(cons '! args) (cons '! (map loop args))]
      [(cons '=> args) (cons '=> (map loop args))]
      [(cons '<=> args) (cons '<=> (map loop args))]
      [x (f x)])))

; Convert an ftree to a feature-model.  Requirements:
; * Each feature in the tree falls into one of three categories:
;   - Top-level features, with gcard = opt and no constraints on card.
;   - Interior features, with gcard = opt and card = opt.
;   - Group features, with gcard != opt and card = on.
; * Each group feature is a child of a non-group feature.
;   (TODO - we don't have a function to enforce this yet, but it only comes up
;   in weird corner cases, since the nested group usually has card = opt, which
;   triggers other transforms)
; * The `feature-order` exactly covers the IDs in `features`
(define (ftree->feature-model ft)
  (define feature-ids
    (for/list ([x (ftree-feature-order ft)]
               #:when (not (fnode-is-group? (ftree-feature ft x))))
      x))
  (define feature-id-map
    (for/hash ([(x i) (in-indexed feature-ids)])
      (values x i)))

  (define group-ids
    (for/list ([x (ftree-feature-order ft)]
               #:when (fnode-is-group? (ftree-feature ft x)))
      x))
  (define group-id-map
    (for/hash ([(x i) (in-indexed group-ids)])
      (values x i)))

  ; Maps for resolving `fnode-parent` relationships.  `parent-feature-map`
  ; gives the `feature-model` `parent-id` to use (which may or may not match
  ; the value in `feature-id-map`), and `parent-group-map` gives the `group-id`
  ; to use.
  (define parent-feature-map (make-hash))
  (define parent-group-map (make-hash))
  (hash-set! parent-feature-map #f -1)
  (hash-set! parent-group-map #f -1)
  (for ([x (ftree-feature-order ft)])
    (define fn (ftree-feature ft x))
    (if (fnode-is-group? fn)
      (begin
        ; Parent is required to be a non-group, so it appears in feature-id-map
        (hash-set! parent-feature-map x (hash-ref feature-id-map (fnode-parent fn)))
        (hash-set! parent-group-map x (hash-ref group-id-map x)))
      (begin
        (hash-set! parent-feature-map x (hash-ref feature-id-map x))
        (hash-set! parent-group-map x -1))
      ))

  (define features
    (for/vector ([x feature-ids])
      (define fn (ftree-feature ft x))
      (define parent-x (fnode-parent fn))
      (when (and parent-x (not (eq? 'opt (fnode-card fn))))
        (raise (format "feature ~a has nonempty parent and nondefault cardinality" x)))
      (feature
        (hash-ref parent-feature-map (fnode-parent fn))
        (hash-ref parent-group-map (fnode-parent fn))
        -1  ; depth is set later
        (eq? 'on (fnode-card fn))
        (eq? 'off (fnode-card fn))
        )))

  (define groups
    (for/vector ([x group-ids])
      (define fn (ftree-feature ft x))
      (define-values (min-card max-card)
        (match (fnode-gcard fn)
          ; Can't be 'opt, otherwise it wouldn't be a group feature.
          ['or (values 1 '*)]
          ['mux (values 0 1)]
          ['xor (values 1 1)]))
      (group
        (hash-ref feature-id-map (fnode-parent fn))
        min-card
        max-card
        )))

  (define constraint
    (rewrite-constraint
      (lambda (c)
        (match c
          [`(feature ,x)
            (define fn (ftree-feature ft x))
            ; TODO - should probably require constraints only mention non-group
            ; features
            (if (fnode-is-group? fn)
              (hash-ref feature-id-map (fnode-parent fn))
              (hash-ref feature-id-map x))]))
      (cons '&& (ftree-constraints ft))))

  (define fm
    (feature-model
      features
      groups
      (vector)
      constraint))
  (recalc-feature-depths fm))

(define (ftree-non-group-feature-order ft)
  (for/list ([k (ftree-feature-order ft)]
             #:when (not (fnode-is-group? (ftree-feature ft k))))
    k))

(define (fresh-feature-id ft base)
  (define features (ftree-features ft))
  (if (not (hash-has-key? features base))
    base
    (let loop ([i 0])
      (define name (format "~a~a" base i))
      (if (not (hash-has-key? features name))
        name
        (loop (add1 i))))))

; Find features with both gcard != opt and card != on, and split them into two
; separate features, one with gcard != opt and a parent feature with card != on
(define (ftree-split-opt-groups! ft)
  (for ([(k fn) (ftree-features ft)]
        #:when (and (fnode-is-group? fn)
                    (not (eq? 'on (fnode-card fn)))))
    (define new-k (fresh-feature-id ft (format "~a-parent" k)))
    (hash-set! (ftree-features ft) new-k
      (fnode
        (fnode-name fn)
        (fnode-parent fn)
        (fnode-card fn)
        'opt))
    (set-fnode-parent! fn new-k)
    (set-fnode-card! fn 'on)))

; Find non-top-level features with card != opt, and replace the card setting
; with a constraint for the same effect.
(define (ftree-force-card-opt! ft)
  (for ([(k fn) (ftree-features ft)]
        #:when (and (not (fnode-is-group? fn))
                    (fnode-parent fn)
                    (not (eq? 'opt (fnode-card fn)))))
    (define rhs
      (match (fnode-card fn)
        ['on `(feature ,k)]
        ['off `(! (feature ,k))]))
    (set-fnode-card! fn 'opt)
    (set-ftree-constraints! ft
      (cons 
        `(=> (feature ,(fnode-parent fn)) ,rhs)
        (ftree-constraints ft)))))

(define (recalc-feature-depths fm)
  (define depth-map (make-hash))
  (hash-set! depth-map -1 -1)
  (define (depth i)
    (hash-ref! depth-map i
      (lambda ()
        (add1 (depth (feature-parent-id (feature-model-feature fm i)))))))

  (struct-copy feature-model fm
    [features
      (for/vector ([(f i) (in-indexed (feature-model-features fm))])
        (struct-copy feature f [depth (depth i)]))]))
